****************************************************************************************************
Recursion
****************************************************************************************************

*Basics
*Problems
*Possible solutions

****************************************************************************************************
*Basics

  Recursion is when you use a function to call itself
  Must have :
    1. A base case
    2. Each call moves toward the base case
    
  Please add additional solutions in your language of choice 
  or recode the javaScript solution into your language or choice 

****************************************************************************************************
*Problems

  1. Print Range
     Print all the numbers in the range including the min and max
     
     input(3, 7)     Output
                     3
                     4
                     5
                     6
                     7
                     
     Bonus : Print the opposite direction from max to min
  
  2. Add all the smaller digits
     
     input(8)
     1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36


  3. Super Digit I
        
     Input a number                                148148
     Add up each digit                             1 + 4 + 8 + 1 + 4 + 8 = 26
     Repeat for that result                        2 + 6 = 8
	 Repeat until the result is only one digit     return 8
            
			
  4. Super Digit II  

     Same as Super Digit I except it also receives a multiplier as a second parameter 
	 The multiplier repeats the number n times

     input(148, 2)         148148         => 2 + 6   => 8
     input(12, 4)          12121212       => 1 + 2   => 3
     input(3, 9)           33333333       => 2 + 4   => 6

     Hint : one way is to put function inside of a function to maintain the original state of the request

  5. Fibonacci I
           
     Find the nth sequence in the fibonacci sequence
     0 + 1 + 1 + 2 + 3 + 5 + 8 + 13 + 21.....
     0   1   2   3   4   5   6   7    8

     input(4) => 3
     input(6) => 8
     input(8) => 21


  6. Fibonacci II - using memonization
     
     Fibonacci I is inefficient O(2^n) 
     My computer crashed before returning a result for 45
     After using memonization it promptly returned a result for 500, and even 5000 returned infinity!
     Fibonacci I builds an entire recursive call from the top of the stack to the bottom of the stack for each calculation
     Each calculation has many sub calculations and the same calculations are getting repeated
     
     Calculate Fibonacci in conjuction with a hash or dictionary object (memonization)
     Before making a recursive call check the hash for a solution, if it exists return the solution
     If it doesn't exist return a recursive call


  7. Sort a hash into a tree

     input                                                           output
        categories = [                                                  {
          {id: “animals”, “parent”: null },                               animals: {
          {id: “mammals”, “parent”: “animals” },                            mammals: {
          {id: “dogs”, “parent”: “mammals” },                                 dogs: {
          {id: “cats”, “parent”: “mammals” },                                   chihuahua: {}
          {id: “chihuahua”, “parent”: “dogs” },                                 labrador: {}
          {id: “labrador”, “parent”: “dogs” },                                }
          {id: “siamese”, “parent”: “cats” }                                  cats: {
         ]                                                                      siamese: {}
                                                                              }
                                                                            }
                                                                          }
                                                                        }
        Hint: 
          1. Filter by id (null first, then animals, then mamals...) 
          2. Make a recursive call to build a tree for each child who has a parent of 'null', 'animals'...


****************************************************************************************************
*Possible Solutions

1. Print Range (javaScript)

  let printRange = (min, max) => {
    if (min === max) return console.log(max);
    console.log(min);
    return printRange(min + 1, max);
  }


2. Add the smaller digits (javaScript)
  
  let addSmallerDigits = (num) => {
    if (num === 1) return 1;
    return num + addSmallerDigits(num - 1);
  }
  
3. Super Digit I (javaScript)

  let superDigit = (num) => {
    if (String(num).length === 1) return num;

    let sum = String(num).split('').reduce( (a, b) => {
      return Number(a) + Number(b);
    });

    return superDigit(sum);
  }

4. Super Digit II (javaScript) using an inner recursion method

  let superDigit = (num, multiplier) => {
    let multiplied = String(num).repeat(multiplier);
  
    let innerSuperDigit = (num) => {
      let sum = String(num).split('').reduce((a, b) => {
        return Number(a) + Number(b);
      });

      if (sum < 10) return sum;
      return innerSuperDigit(sum);
    }

    return innerSuperDigit(multiplied);
  }
  
4. Super Digit II (ruby) without inner recurion function
  
  def superDigit(num, multiplier)
    multiplied = num.to_s * multiplier

    if (multiplied.length == 1)
      return multiplied
    end

    sum = multiplied.to_s.split('').reduce do |a, b| 
      a.to_i + b.to_i
    end

    superDigit(sum, 1)
  end


5. Fibonacci I (javaScript)
  
  let fibonacci = (n) => {
    if (n === 0) return 0;
    if (n <= 2) return 1;
    
    return fibonacci(n - 1) + fibonacci(n - 2);
  }


6. Fibonacci II (javaScript) using memonization

  function fib(n, savedFib) {
    savedFib = savedFib || {};
    
    if (n <= 0) return 0; 
    if (n <= 2) return 1; 

    if (!savedFib[n - 1]) savedFib[n - 1] = fib(n - 1, savedFib);
    if (!savedFib[n - 2]) savedFib[n - 2] = fib(n - 2, savedFib);

    return savedFib[n - 1] + savedFib[n - 2];
  }


7. Sort a hash into a tree (javaScript)
  
  let makeTree = (categories, parent) => {
    let node = {}
    categories
      .filter(c => c.parent === parent) 
      .forEach(c => 
        node[c.id] = makeTree(categories, c.id));
    return node;
  }

